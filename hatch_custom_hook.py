# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
import os
import shutil
from typing import Any

from hatchling.builders.hooks.plugin.interface import BuildHookInterface


class HatchCustomBuildHook(BuildHookInterface):
    """
    This class implements Hatch's [custom build hook] (https://hatch.pypa.io/1.6/plugins/build-hook/custom/)
    for a copy_version_py operation that copies the _version.py file generated by the hatch-vcs build hook into
    specified destination directories. See the `[[tool.hatch.build.hooks.custom]]` section in `pyproject.toml`.
    """

    def _validate_config(self):
        if sorted(self.config) != ["blender_addon_init", "copy_version_py", "path"] or list(
            self.config["copy_version_py"]
        ) != ["destinations"]:
            raise RuntimeError(
                "Configuration of the custom build hook must be like { 'copy_version_py': {'destinations': ['path1', ...]}}."
                + f" Received:\n{self.config}"
            )

    def initialize(self, version: str, build_data: dict[str, Any]) -> None:
        self._validate_config()

        for destination in self.config["copy_version_py"]["destinations"]:
            print(f"Copying _version.py to {destination}")
            shutil.copy(
                os.path.join(self.root, "_version.py"),
                os.path.join(self.root, destination),
            )
        # Update version in Blender addon
        self._update_addon_version()

    def _update_addon_version(self):
        __ver__ = {}
        with open(os.path.join(self.root, "_version.py")) as fp:
            exec(fp.read(), __ver__)
        ver_tuple = __ver__["version_tuple"]
        major, minor, patch = ver_tuple[:3]  # Cut off the commit hash part
        try:
            int(patch)
        except ValueError:
            patch = f'"{patch}"'
        addon_init_file = os.path.join(self.root, self.config["blender_addon_init"])
        print(f"Updating version in blender addon: {addon_init_file}")
        with open(addon_init_file, "rt") as rf:
            lines = rf.readlines()
        new_lines = list()
        for line in lines:
            if '"version":' not in line:
                new_lines.append(line)
                continue
            new_lines.append(f'    "version": ({major}, {minor}, {patch}),\n'.format())
        with open(addon_init_file, "wt") as wf:
            wf.writelines(new_lines)

    def clean(self, versions: list[str]) -> None:
        self._validate_config()

        cleaned_count = 0
        for destination in self.config["copy_version_py"]["destinations"]:
            print(f"Cleaning _version.py from {destination}")
            clean_path = os.path.join(self.root, destination, "_version.py")
            try:
                os.remove(clean_path)
                cleaned_count += 1
            except FileNotFoundError:
                pass
        print(f"Cleaned {cleaned_count} items")
